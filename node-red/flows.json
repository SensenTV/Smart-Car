[
    {
        "id": "flow_main",
        "type": "tab",
        "label": "Smart-Car Hauptflow",
        "disabled": false,
        "info": "Hauptdatenverarbeitung: MQTT - Parsing - InfluxDB\n\nDieser Flow empfaengt Daten von ESP32-Geraeten ueber MQTT,\nkonvertiert sie ins InfluxDB Line Protocol und speichert sie."
    },
    {
        "id": "flow_test",
        "type": "tab",
        "label": "Test und Simulation",
        "disabled": false,
        "info": "Manuelle Testdaten ohne ESP32-Hardware"
    },
    {
        "id": "config_mqtt_internal",
        "type": "mqtt-broker",
        "name": "MQTT Broker (Mosquitto)",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "nodered-smartcar",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "birthTopic": "smartcar/system/status",
        "birthPayload": "Node-RED online",
        "birthQos": "1",
        "closeTopic": "smartcar/system/status",
        "closePayload": "Node-RED offline",
        "closeQos": "1",
        "willTopic": "smartcar/system/status",
        "willPayload": "Node-RED disconnected",
        "willQos": "1"
    },
    {
        "id": "mqtt_in_vehicles",
        "type": "mqtt in",
        "z": "flow_main",
        "name": "MQTT Empfang",
        "topic": "smartcar/+",
        "qos": "1",
        "datatype": "utf8",
        "broker": "config_mqtt_internal",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 120,
        "y": 100,
        "wires": [["func_validate", "debug_raw"]]
    },
    {
        "id": "func_validate",
        "type": "function",
        "z": "flow_main",
        "name": "Validierung",
        "func": "// Eingabevalidierung vor Parsing\nlet payload = msg.payload;\n\n// Pruefe ob Payload vorhanden\nif (!payload || payload.length === 0) {\n    node.warn('Leere Nachricht empfangen');\n    node.status({fill:'yellow', shape:'ring', text: 'Leer'});\n    return null;\n}\n\n// Pruefe minimale Laenge (type,vid,...)\nif (payload.length < 10) {\n    node.warn('Nachricht zu kurz: ' + payload);\n    node.status({fill:'yellow', shape:'ring', text: 'Zu kurz'});\n    return null;\n}\n\n// Pruefe auf bekannte Typen\nlet type = payload.split(',')[0].toLowerCase();\nlet validTypes = ['state', 'error', 'trip', 'gps', 'alert'];\n\nif (!validTypes.includes(type)) {\n    node.warn('Unbekannter Typ: ' + type);\n    node.status({fill:'yellow', shape:'ring', text: 'Typ: ' + type});\n    return null;\n}\n\nnode.status({fill:'green', shape:'dot', text: type});\nreturn msg;",
        "outputs": 1,
        "x": 290,
        "y": 100,
        "wires": [["func_parse_csv"]]
    },
    {
        "id": "debug_raw",
        "type": "debug",
        "z": "flow_main",
        "name": "Raw MQTT",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "x": 290,
        "y": 160,
        "wires": []
    },
    {
        "id": "func_parse_csv",
        "type": "function",
        "z": "flow_main",
        "name": "CSV Parser",
        "func": "/**\n * CSV zu InfluxDB Line Protocol Konverter\n * \n * Unterstuetzte Formate:\n * - state,VID,state_name,fuel,battery\n * - error,VID,error_code,active\n * - trip,VID,trip_id,duration,fuel_used,max_acc,max_brake\n * - gps,VID,lat,lon,speed\n * - alert,VID,alert_type,message\n */\n\nconst topicParts = msg.topic.split('/');\nconst vehicle_id = topicParts[1] || 'UNKNOWN';\nconst cols = msg.payload.toString().trim().split(',');\nconst type = cols[0].toLowerCase();\nconst ts = Date.now() * 1000000; // Nanosekunden\n\nlet line = '';\nlet success = false;\n\ntry {\n    switch(type) {\n        case 'state': {\n            if (cols.length < 5) throw new Error('state braucht 5 Felder');\n            const state = (cols[2] || 'unknown').replace(/[^a-zA-Z0-9]/g, '');\n            const fuel = parseFloat(cols[3]);\n            const battery = parseFloat(cols[4]);\n            \n            if (isNaN(fuel) || isNaN(battery)) throw new Error('Ungueltige Zahlenwerte');\n            if (fuel < 0 || fuel > 100) throw new Error('Kraftstoff ausserhalb Bereich');\n            if (battery < 0 || battery > 20) throw new Error('Batterie ausserhalb Bereich');\n            \n            line = `vehicle_state,vehicle_id=${vehicle_id},state=${state} fuel_l=${fuel},battery_v=${battery},online=1i ${ts}`;\n            success = true;\n            break;\n        }\n        case 'error': {\n            if (cols.length < 4) throw new Error('error braucht 4 Felder');\n            const error_code = cols[2].replace(/[^a-zA-Z0-9_]/g, '');\n            const active = parseInt(cols[3]) === 1 ? 1 : 0;\n            \n            line = `vehicle_errors,vehicle_id=${vehicle_id},error_code=${error_code} active=${active}i ${ts}`;\n            success = true;\n            break;\n        }\n        case 'trip': {\n            if (cols.length < 7) throw new Error('trip braucht 7 Felder');\n            const trip_id = cols[2].replace(/[^a-zA-Z0-9_]/g, '');\n            const duration = parseInt(cols[3]) || 0;\n            const fuel_used = parseFloat(cols[4]) || 0;\n            const max_acc = parseFloat(cols[5]) || 0;\n            const max_brake = parseFloat(cols[6]) || 0;\n            \n            line = `trip_summary,vehicle_id=${vehicle_id},trip_id=${trip_id} duration_s=${duration}i,fuel_used=${fuel_used},max_acceleration=${max_acc},max_braking=${max_brake} ${ts}`;\n            success = true;\n            break;\n        }\n        case 'gps': {\n            if (cols.length < 5) throw new Error('gps braucht 5 Felder');\n            const lat = parseFloat(cols[2]);\n            const lon = parseFloat(cols[3]);\n            const speed = parseFloat(cols[4]) || 0;\n            \n            if (isNaN(lat) || isNaN(lon)) throw new Error('Ungueltige GPS-Koordinaten');\n            if (lat < -90 || lat > 90) throw new Error('Breitengrad ausserhalb Bereich');\n            if (lon < -180 || lon > 180) throw new Error('Laengengrad ausserhalb Bereich');\n            \n            line = `vehicle_gps,vehicle_id=${vehicle_id} latitude=${lat},longitude=${lon},speed_kmh=${speed} ${ts}`;\n            success = true;\n            break;\n        }\n        case 'alert': {\n            if (cols.length < 3) throw new Error('alert braucht min. 3 Felder');\n            const alert_type = cols[2].replace(/[^a-zA-Z0-9_]/g, '');\n            const alert_msg = (cols[3] || '').replace(/\"/g, \"'\");\n            \n            line = `alerts,vehicle_id=${vehicle_id},alert_type=${alert_type} message=\"${alert_msg}\" ${ts}`;\n            success = true;\n            break;\n        }\n        default:\n            throw new Error('Unbekannter Typ: ' + type);\n    }\n    \n    if (success) {\n        msg.payload = line;\n        msg.headers = {\n            'Authorization': 'Token vehicle-admin-token',\n            'Content-Type': 'text/plain; charset=utf-8'\n        };\n        msg._parsed = { type, vehicle_id, timestamp: ts };\n        node.status({fill:'green', shape:'dot', text: `${type} ${vehicle_id}`});\n        return [msg, null];\n    }\n    \n} catch(e) {\n    node.error('Parse-Fehler: ' + e.message, msg);\n    node.status({fill:'red', shape:'ring', text: e.message});\n    msg.error = e.message;\n    return [null, msg];\n}\n\nreturn null;",
        "outputs": 2,
        "outputLabels": ["Erfolg", "Fehler"],
        "x": 430,
        "y": 100,
        "wires": [["http_influx", "debug_line"], ["debug_error"]]
    },
    {
        "id": "debug_line",
        "type": "debug",
        "z": "flow_main",
        "name": "Line Protocol",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "x": 600,
        "y": 160,
        "wires": []
    },
    {
        "id": "debug_error",
        "type": "debug",
        "z": "flow_main",
        "name": "Parse-Fehler",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "x": 600,
        "y": 220,
        "wires": []
    },
    {
        "id": "http_influx",
        "type": "http request",
        "z": "flow_main",
        "name": "InfluxDB Write",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://influxdb:8086/api/v2/write?org=vehicle_org&bucket=vehicle_data&precision=ns",
        "tls": "",
        "persist": true,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "x": 600,
        "y": 100,
        "wires": [["func_check_response"]]
    },
    {
        "id": "func_check_response",
        "type": "function",
        "z": "flow_main",
        "name": "Response Check",
        "func": "const statusCode = msg.statusCode;\n\nif (statusCode === 204) {\n    // Erfolg - InfluxDB gibt 204 bei erfolgreichem Schreiben\n    node.status({fill:'green', shape:'dot', text: 'OK'});\n    return [msg, null];\n} else if (statusCode >= 400) {\n    // Fehler\n    node.error(`InfluxDB Fehler ${statusCode}: ${msg.payload}`, msg);\n    node.status({fill:'red', shape:'ring', text: `Fehler ${statusCode}`});\n    return [null, msg];\n} else {\n    node.status({fill:'yellow', shape:'ring', text: `Code ${statusCode}`});\n    return [msg, null];\n}",
        "outputs": 2,
        "outputLabels": ["Erfolg", "Fehler"],
        "x": 800,
        "y": 100,
        "wires": [["debug_success"], ["debug_influx_error"]]
    },
    {
        "id": "debug_success",
        "type": "debug",
        "z": "flow_main",
        "name": "Gespeichert",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "_parsed",
        "x": 990,
        "y": 100,
        "wires": []
    },
    {
        "id": "debug_influx_error",
        "type": "debug",
        "z": "flow_main",
        "name": "InfluxDB Fehler",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "x": 1000,
        "y": 160,
        "wires": []
    },
    {
        "id": "comment_header",
        "type": "comment",
        "z": "flow_main",
        "name": "=== SMART-CAR DATENVERARBEITUNG ===",
        "info": "MQTT Empfang -> Validierung -> Parsing -> InfluxDB\n\nFehlerbehandlung auf jeder Stufe.",
        "x": 200,
        "y": 40,
        "wires": []
    },
    {
        "id": "comment_manual",
        "type": "comment",
        "z": "flow_test",
        "name": "=== MANUELLE EINZELTESTS ===",
        "info": "Klicke auf die blauen Buttons um einzelne Testdaten zu senden.",
        "x": 180,
        "y": 40,
        "wires": []
    },
    {
        "id": "inject_status",
        "type": "inject",
        "z": "flow_test",
        "name": "Status",
        "props": [{"p": "payload"}, {"p": "topic", "vt": "str"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "smartcar/TEST001",
        "payload": "state,TEST001,driving,42.5,12.8",
        "payloadType": "str",
        "x": 130,
        "y": 100,
        "wires": [["mqtt_out_test"]]
    },
    {
        "id": "inject_error",
        "type": "inject",
        "z": "flow_test",
        "name": "Fehler",
        "props": [{"p": "payload"}, {"p": "topic", "vt": "str"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "smartcar/TEST001",
        "payload": "error,TEST001,E001,1",
        "payloadType": "str",
        "x": 130,
        "y": 160,
        "wires": [["mqtt_out_test"]]
    },
    {
        "id": "inject_trip",
        "type": "inject",
        "z": "flow_test",
        "name": "Fahrt",
        "props": [{"p": "payload"}, {"p": "topic", "vt": "str"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "smartcar/TEST001",
        "payload": "trip,TEST001,TRIP001,3600,5.2,3.5,4.1",
        "payloadType": "str",
        "x": 130,
        "y": 220,
        "wires": [["mqtt_out_test"]]
    },
    {
        "id": "inject_alert",
        "type": "inject",
        "z": "flow_test",
        "name": "Alarm",
        "props": [{"p": "payload"}, {"p": "topic", "vt": "str"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "smartcar/TEST001",
        "payload": "alert,TEST001,low_fuel,Kraftstoff unter 10 Prozent",
        "payloadType": "str",
        "x": 130,
        "y": 280,
        "wires": [["mqtt_out_test"]]
    },
    {
        "id": "inject_gps",
        "type": "inject",
        "z": "flow_test",
        "name": "GPS",
        "props": [{"p": "payload"}, {"p": "topic", "vt": "str"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "smartcar/TEST001",
        "payload": "gps,TEST001,52.5200,13.4050,65",
        "payloadType": "str",
        "x": 130,
        "y": 340,
        "wires": [["mqtt_out_test"]]
    },
    {
        "id": "comment_sim",
        "type": "comment",
        "z": "flow_test",
        "name": "=== KONTINUIERLICHE SIMULATION ===",
        "info": "START: Beginnt alle 5 Sekunden automatisch Daten zu generieren\nSTOP: Beendet die Simulation",
        "x": 200,
        "y": 420,
        "wires": []
    },
    {
        "id": "inject_start",
        "type": "inject",
        "z": "flow_test",
        "name": "START",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "start",
        "payloadType": "str",
        "x": 130,
        "y": 480,
        "wires": [["func_controller"]]
    },
    {
        "id": "inject_stop",
        "type": "inject",
        "z": "flow_test",
        "name": "STOP",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "stop",
        "payloadType": "str",
        "x": 130,
        "y": 540,
        "wires": [["func_controller"]]
    },
    {
        "id": "inject_ticker",
        "type": "inject",
        "z": "flow_test",
        "name": "Ticker 5s",
        "props": [{"p": "payload"}],
        "repeat": "5",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "tick",
        "payloadType": "str",
        "x": 140,
        "y": 600,
        "wires": [["func_controller"]]
    },
    {
        "id": "func_controller",
        "type": "function",
        "z": "flow_test",
        "name": "Controller",
        "func": "// Simulation Controller\n// Steuert ob die Simulation laeuft oder nicht\n\nconst cmd = msg.payload;\n\nif (cmd === 'start') {\n    flow.set('running', true);\n    flow.set('startTime', Date.now());\n    node.status({fill:'green', shape:'dot', text: 'Laeuft'});\n    node.warn('Simulation gestartet');\n    return null;\n}\n\nif (cmd === 'stop') {\n    flow.set('running', false);\n    const duration = Math.round((Date.now() - (flow.get('startTime') || Date.now())) / 1000);\n    node.status({fill:'red', shape:'ring', text: `Gestoppt (${duration}s)`});\n    node.warn('Simulation gestoppt nach ' + duration + ' Sekunden');\n    return null;\n}\n\nif (cmd === 'tick') {\n    if (flow.get('running')) {\n        return msg;\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "x": 320,
        "y": 540,
        "wires": [["func_generator"]]
    },
    {
        "id": "func_generator",
        "type": "function",
        "z": "flow_test",
        "name": "Fahrzeug-Simulator",
        "func": "/**\n * Simuliert realistische Fahrzeugdaten\n * Wechselt zwischen Zustaenden und aendert Werte graduell\n */\n\nconst VEHICLES = ['TEST001', 'TEST002', 'TEST003'];\nconst STATES = ['idle', 'driving', 'charging', 'parked'];\n\n// Fahrzeugkontext laden oder initialisieren\nlet vehicles = context.get('vehicles') || {};\n\n// Zufaelliges Fahrzeug waehlen\nconst vid = VEHICLES[Math.floor(Math.random() * VEHICLES.length)];\n\n// Fahrzeug initialisieren falls nicht vorhanden\nif (!vehicles[vid]) {\n    vehicles[vid] = {\n        fuel: 30 + Math.random() * 30,\n        battery: 12.2 + Math.random() * 1.5,\n        state: STATES[Math.floor(Math.random() * STATES.length)],\n        stateCounter: 0,\n        lat: 52.52 + (Math.random() - 0.5) * 0.1,\n        lon: 13.405 + (Math.random() - 0.5) * 0.1\n    };\n}\n\nconst v = vehicles[vid];\n\n// Zustandswechsel alle 8-15 Zyklen\nv.stateCounter++;\nif (v.stateCounter >= 8 + Math.floor(Math.random() * 7)) {\n    v.stateCounter = 0;\n    const currentIdx = STATES.indexOf(v.state);\n    v.state = STATES[(currentIdx + 1) % STATES.length];\n}\n\n// Werte basierend auf Zustand aendern\nswitch(v.state) {\n    case 'driving':\n        v.fuel = Math.max(5, v.fuel - 0.2 - Math.random() * 0.3);\n        v.battery = Math.max(11.5, v.battery - 0.01 - Math.random() * 0.02);\n        v.lat += (Math.random() - 0.5) * 0.002;\n        v.lon += (Math.random() - 0.5) * 0.002;\n        break;\n    case 'charging':\n        v.fuel = Math.min(60, v.fuel + 0.3 + Math.random() * 0.4);\n        v.battery = Math.min(14.2, v.battery + 0.03 + Math.random() * 0.03);\n        break;\n    case 'idle':\n        v.battery = Math.min(13.8, v.battery + 0.005);\n        break;\n    case 'parked':\n        v.battery = Math.max(12, v.battery - 0.002);\n        break;\n}\n\ncontext.set('vehicles', vehicles);\n\n// Nachricht erstellen\nmsg.topic = 'smartcar/' + vid;\nmsg.payload = `state,${vid},${v.state},${v.fuel.toFixed(1)},${v.battery.toFixed(2)}`;\n\nnode.status({fill:'blue', shape:'dot', text: `${vid}: ${v.state}`});\n\n// Zufaellig auch GPS senden (30% Chance)\nif (Math.random() < 0.3 && v.state === 'driving') {\n    const speed = 30 + Math.floor(Math.random() * 90);\n    const gpsMsg = {\n        topic: 'smartcar/' + vid,\n        payload: `gps,${vid},${v.lat.toFixed(4)},${v.lon.toFixed(4)},${speed}`\n    };\n    return [msg, gpsMsg];\n}\n\nreturn [msg, null];",
        "outputs": 2,
        "outputLabels": ["Status", "GPS"],
        "x": 530,
        "y": 540,
        "wires": [["mqtt_out_test"], ["mqtt_out_test"]]
    },
    {
        "id": "mqtt_out_test",
        "type": "mqtt out",
        "z": "flow_test",
        "name": "MQTT Publish",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "config_mqtt_internal",
        "x": 750,
        "y": 280,
        "wires": []
    },
    {
        "id": "comment_multi",
        "type": "comment",
        "z": "flow_test",
        "name": "=== MEHRERE FAHRZEUGE ===",
        "info": "Simulation mit 3 virtuellen Fahrzeugen:\nTEST001, TEST002, TEST003",
        "x": 180,
        "y": 680,
        "wires": []
    },
    {
        "id": "inject_multi_start",
        "type": "inject",
        "z": "flow_test",
        "name": "ALLE STARTEN",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "start_all",
        "payloadType": "str",
        "x": 160,
        "y": 740,
        "wires": [["func_multi_gen"]]
    },
    {
        "id": "inject_multi_stop",
        "type": "inject",
        "z": "flow_test",
        "name": "ALLE STOPPEN",
        "props": [{"p": "payload"}],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "stop_all",
        "payloadType": "str",
        "x": 160,
        "y": 800,
        "wires": [["func_multi_gen"]]
    },
    {
        "id": "inject_multi_tick",
        "type": "inject",
        "z": "flow_test",
        "name": "Multi-Ticker 3s",
        "props": [{"p": "payload"}],
        "repeat": "3",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "tick_all",
        "payloadType": "str",
        "x": 160,
        "y": 860,
        "wires": [["func_multi_gen"]]
    },
    {
        "id": "func_multi_gen",
        "type": "function",
        "z": "flow_test",
        "name": "Multi-Fahrzeug Generator",
        "func": "// Generiert Daten fuer mehrere Fahrzeuge gleichzeitig\n\nconst cmd = msg.payload;\n\nif (cmd === 'start_all') {\n    flow.set('multi_running', true);\n    node.status({fill:'green', shape:'dot', text: '3 Fahrzeuge aktiv'});\n    return null;\n}\n\nif (cmd === 'stop_all') {\n    flow.set('multi_running', false);\n    node.status({fill:'red', shape:'ring', text: 'Gestoppt'});\n    return null;\n}\n\nif (cmd === 'tick_all' && flow.get('multi_running')) {\n    const vehicles = ['CAR001', 'CAR002', 'CAR003'];\n    const states = ['idle', 'driving', 'charging', 'parked'];\n    const messages = [];\n    \n    vehicles.forEach(vid => {\n        let v = context.get(vid) || {\n            fuel: 30 + Math.random() * 30,\n            battery: 12 + Math.random() * 2,\n            state: states[Math.floor(Math.random() * 4)]\n        };\n        \n        // Zufaellige Aenderungen\n        if (Math.random() < 0.2) {\n            v.state = states[Math.floor(Math.random() * 4)];\n        }\n        if (v.state === 'driving') {\n            v.fuel = Math.max(5, v.fuel - 0.3);\n        } else if (v.state === 'charging') {\n            v.fuel = Math.min(60, v.fuel + 0.5);\n        }\n        \n        context.set(vid, v);\n        \n        messages.push({\n            topic: 'smartcar/' + vid,\n            payload: `state,${vid},${v.state},${v.fuel.toFixed(1)},${v.battery.toFixed(2)}`\n        });\n    });\n    \n    node.status({fill:'blue', shape:'dot', text: `${messages.length} Nachrichten`});\n    return [messages];\n}\n\nreturn null;",
        "outputs": 1,
        "x": 410,
        "y": 800,
        "wires": [["mqtt_out_test"]]
    }
]
